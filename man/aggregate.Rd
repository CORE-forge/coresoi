% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/composite.R
\name{aggregate}
\alias{aggregate}
\title{Aggregate the elementary indicators on the provided data matrix}
\usage{
aggregate(data, method = "linear", w)
}
\arguments{
\item{data}{data matrix with the set of \strong{normalised} elementary indicators
(without missing values).}

\item{method}{aggregation method. Possible choices: \code{"linear"} (default) and \code{"non-linear"}. See Details.}

\item{w}{vector of weights, as returned by \code{\link[=get_weights]{get_weights()}}.}
}
\value{
vector of composite indicator values for each target unit in \code{data}.
}
\description{
\code{aggregate} aggregates the set of elementary indicators through the selected
method and computes the composite according to the specified set of weights.
}
\details{
The choice of the aggregation method heavily depends on the degree of compensability
or substitutability of the elementary indicators. A compensatory approach requires the use of
\emph{linear} functions (e.g., a linear combination of the elementary indicators), while
a partially compensatory (or non-compensatory) approach involves \emph{non-linear} functions
(e.g., a multiplicative approach).

In the first case, which corresponds to set \code{method = "linear"}, the composite indicator
for target unit \eqn{c} is obtained as weighted (according to \code{w}) arithmetic mean of the \eqn{Q}
elementary (and normalised) indicators \eqn{I_{qc}}:

\deqn{CI_c = \sum_{q=1}^Q w_q I_{qc}}

In the second case, using \code{method = "non-linear"}, the resulting composite indicator is obtained
as weighted geometric mean of the elementary indicators:

\deqn{CI_c = \prod_{q=1}^Q I_{qc}^{w_q}}
}
\examples{
\dontrun{
if (interactive()) {
  mock_data_core_variants <- unnest(mock_data_core, varianti, keep_empty = TRUE)
  out_companies <- ind_all(
    data = mock_data_core,
    data_ind8 = mock_data_core_variants,
    emergency_name = "coronavirus",
    target_unit = "companies"
  )
  data_matrix <- create_indicator_matrix(out_companies)
  data_matrix_norm <- normalise(data_matrix, method = "binary", cutoff = 0.95)
  data_matrix_norm_nomiss <- manage_missing(data_matrix_norm, missing = 0)
  w <- get_weights(data_matrix_norm_nomiss, method = "equal")
  out_aggr <- aggregate(data_matrix_norm_nomiss, method = "linear", w) # it is a composite indicator
}
}
}
