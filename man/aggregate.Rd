% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/composite.R
\name{aggregate}
\alias{aggregate}
\title{aggregate}
\usage{
aggregate(data, method = "linear", w)
}
\arguments{
\item{data}{data matrix with the set of \strong{normalised} elementary indicators
(without missing values).}

\item{method}{aggregation method. Possible choices: \code{"linear"} (default) and \code{"non-linear"}. See Details.}

\item{w}{vector of weights, as returned by \code{\link[=get_weights]{get_weights()}}.}
}
\value{
vector of composite indicators for each target unit in \code{data}.
}
\description{
\code{aggregate} aggregates the set of elementary indicators through the selected
method and computes the composite according to the specified set of weights.
}
\details{
Aggregate the elementary indicators and compute the composite

The choice of the aggregation method heavily depends on the degree of compensability
or substitutability of the elementary indicators. A compensatory approach requires the use of
\emph{linear} functions (e.g., a linear combination of the elementary indicators), while
a partially compensatory (or non-compensatory) approach involves \emph{non-linear} functions
(e.g., a multiplicative approach).

In the first case, which corresponds to set \code{method = "linear"}, the composite indicator
for target unit \eqn{c} is obtained as weighted (according to \code{w}) arithmetic mean of the \eqn{Q}
elementary (and normalised) indicators \eqn{I_{qc}}:

\deqn{CI_c = \sum_{q=1}^Q w_q I_{qc}}

In the second case, using \code{method = "non-linear"}, the resulting composite indicator is obtained
as weighted geometric mean of the elementary indicators:

\deqn{CI_c = \prod_{q=1}^Q I_{qc}^{w_q}}
}
